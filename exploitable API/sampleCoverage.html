<html>
<head><title>webgl test</title></head>
<body>


<canvas id='myCanvas' width='256' height='256'></canvas>
<div id="res"></div>

<script src="three.js"></script>
<script src="EffectComposer.js"></script>
<script>
Uint8Array.prototype.hashCode = function() {
  var hash = 0, i, chr, len;
  if (this.length === 0)
	return hash;
  for (i = 0, len = this.length; i < len; i++) {
	chr = this[i];
	hash = ((hash << 5) - hash) + chr;
	hash |= 0; // Convert to 32bit integer
  }
  return hash;
}

String.prototype.hashCode = function() {
  var hash = 0, i, chr;
  if (this.length === 0) return hash;
  for (i = 0; i < this.length; i++) {
	chr   = this.charCodeAt(i);
	hash  = ((hash << 5) - hash) + chr;
	hash |= 0; // Convert to 32bit integer
  }
  return hash;
};
</script>
<script>


var canvas = document.getElementById("myCanvas");
var gl = canvas.getContext('webgl',{ antialias: true, depth: false });

if (!gl) {
	console.log('can not use webgl');
}


var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
console.log( gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) );
// GPU 制造商，e.g., Intel Inc.
console.log( gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) );
// GPU 型号，e.g., Intel Iris OpenGL Engine	
	

function loadShader(type, shaderSource) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, shaderSource);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert("Error compiling shader" + gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);   
      return null;
  }
  return shader;  
}


var vertexShaderSource = `
	attribute vec4 a_Position;
    void main() {
        gl_Position = a_Position;
    }
`
	
	
var fragmentShaderSource = `
	precision mediump float;
	void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
`
	
var vertexShader = loadShader(gl.VERTEX_SHADER, vertexShaderSource);
var fragmentShader = loadShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

var shaderProgram = gl.createProgram();
gl.attachShader(shaderProgram, vertexShader);
gl.attachShader(shaderProgram, fragmentShader);
gl.linkProgram(shaderProgram);

if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
	alert("Failed to setup shaders");
}

gl.useProgram(shaderProgram);	
	
const vertices = new Float32Array([
	-1.0, -1.0,
	1.0, -1.0,
	0, 0.574
])
// 创建缓冲区，缓冲区我的理解是js将数据存在里面，着色器才可以拿的到数据
const vertexBuffer = gl.createBuffer()
// 绑定缓存区到当前webgl渲染上下文
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
// 将坐标值传入缓冲区
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)

// 获取a_Position在缓冲区的地址，目的是确定传入的坐标应用到顶点着色器中的哪一个变量
const a_position = gl.getAttribLocation(shaderProgram, 'a_Position')
gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0)

// 让顶点着色器的a_position可以从缓冲区中拿数据
gl.enableVertexAttribArray(a_position)
	
	
gl.enable(gl.SAMPLE_COVERAGE);
gl.sampleCoverage(0.5, false);	

gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);	
	

gl.drawArrays(gl.TRIANGLES, 0, 3);

var div = document.getElementById('res');
div.innerHTML = "Your fingerprint: " + canvas.toDataURL().hashCode();

</script>
</body>
</html>