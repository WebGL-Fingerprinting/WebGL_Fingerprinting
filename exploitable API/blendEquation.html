<html>
<head><title>webgl test</title>
<meta http-equiv="Expires" content="0">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Cache" content="no-cache">
</head>
<body>

<canvas id='myCanvas' width='256' height='256'></canvas>

<div id="res"></div>


<script>
String.prototype.hashCode = function() {
  var hash = 0, i, chr;
  if (this.length === 0) return hash;
  for (i = 0; i < this.length; i++) {
	chr   = this.charCodeAt(i);
	hash  = ((hash << 5) - hash) + chr;
	hash |= 0; // Convert to 32bit integer
  }
  return hash;
};

function createShader(gl, type, source) {
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	if (success) {
	return shader;
	}

	console.log(gl.getShaderInfoLog(shader));  // eslint-disable-line
	gl.deleteShader(shader);
	return undefined;
}

function createProgram(gl, vertexShader, fragmentShader) {
var program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
var success = gl.getProgramParameter(program, gl.LINK_STATUS);
if (success) {
	return program;
}

console.log(gl.getProgramInfoLog(program));  // eslint-disable-line
gl.deleteProgram(program);
return undefined;
}

// 设置矩形坐标
function setRectangle(gl, x, y, width, height) {
  var x1 = x;
  var x2 = x + width;
  var y1 = y;
  var y2 = y + height;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x2, y2,
  ]), gl.STATIC_DRAW);
}

//加载图片作为纹理
var img = new Image();
var dataurl = "";
img.src = '3d.png';
img.onload = function(){

	var canvas = document.getElementById("myCanvas");
	//canvas rendering前没有差异
	var gl = canvas.getContext('webgl',{ antialias: false, depth: false, premultipliedAlpha:true });

	if (!gl) {
		console.log('can not use webgl');
	}


	var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
	var vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
	var render = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
	console.log( vendor );
	console.log( render );

	let vertexShader = gl.createShader(gl.VERTEX_SHADER);
	let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

	let vsText = `
		//	顶点着色器程序
		attribute vec2 a_position;
		attribute vec2 a_texCoord;

		uniform vec2 u_resolution;

		varying vec2 v_texCoord;

		void main() {
			// 从像素坐标转换到 0.0 到 1.0
			vec2 zeroToOne = a_position / u_resolution;

			// 再把 0->1 转换 0->2
			vec2 zeroToTwo = zeroToOne * 2.0;

			// 把 0->2 转换到 -1->+1 (裁剪空间)
			vec2 clipSpace = zeroToTwo - 1.0;

			gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

			// 将纹理坐标传给片断着色器
			// GPU会在点之间进行插值
			v_texCoord = a_texCoord;
		}
	`
	let fsText = `
		//片段着色器程序
		precision mediump float;
		// 纹理
		uniform sampler2D u_image;
		// 从顶点着色器传入的纹理坐标
		varying vec2 v_texCoord;
		void main() {
			// 在纹理上寻找对应颜色值
			gl_FragColor = texture2D(u_image, v_texCoord);
			//gl_FragColor = vec4(1.0, 0, 0, 1.0);
		}
	`

	gl.shaderSource(vertexShader, vsText);
	gl.shaderSource(fragmentShader, fsText);

	gl.compileShader(vertexShader);
	gl.compileShader(fragmentShader);
	if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
		console.error('ERROR compiling vertex shader!',
		gl.getShaderInfoLog(vertexShader));
	}

	let program = gl.createProgram();
	gl.attachShader(program, vertexShader);
	gl.attachShader(program, fragmentShader);
	gl.linkProgram(program);
	gl.validateProgram(program);

	// 使用着色器程序
	gl.useProgram(program);

	// 指定从哪获取顶点数据
	let positionLocation = gl.getAttribLocation(program, "a_position");
	let texcoordLocation = gl.getAttribLocation(program, "a_texCoord");

	// 创建坐标缓存
	var positionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	setRectangle(gl, 0, 0, gl.canvas.width, gl.canvas.height);

	// 为矩形提供纹理坐标
	var texcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
		0.0, 0.0,
		1.0, 0.0,
		0.0, 1.0,
		1.0, 1.0
	]), gl.STATIC_DRAW);

	// 创建下标缓存
	const indexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	const indices = [
		0, 1, 2,   // first triangle
		2, 1, 3,   // second triangle
	];
	gl.bufferData(
		gl.ELEMENT_ARRAY_BUFFER,
		new Uint16Array(indices),
		gl.STATIC_DRAW
	);

	// 创建纹理
	var texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);

	// 将图片上传到纹理中
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

	// 设置参数，以便渲染任意大小的图片
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);


	gl.enableVertexAttribArray(positionLocation);
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

	gl.enableVertexAttribArray(texcoordLocation);
	gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
	gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);



	// 指定从哪获取uniform
	let resolutionLocation = gl.getUniformLocation(program, "u_resolution");
	// 设置分辨率
	gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

	// 告诉WebGL如何从剪辑空间转换为像素
	gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);



	// 清空canvas
	gl.clearColor(0.12, 0.34, 0.56, 0.78);
	gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

	gl.enable(gl.BLEND);
	gl.blendColor(0.5, 0.5, 0.5, 0.5);
	gl.blendEquation(gl.FUNC_SUBTRACT);
	console.log('blendColor: ', gl.getParameter(gl.BLEND_COLOR));
	//目的颜色乘以源alpha会产生bug
	//部分区域的alpha被乘以了两次，看起来像是重叠部分被乘以了两次
	gl.blendFunc(gl.ONE, gl.SRC_ALPHA);	//work		SRC_ALPHA

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	
	//用readpixel等图片画完之后再用todataurl提取渲染结果
//	console.log('DataURL: ', gl.canvas.toDataURL().hashCode());
	var div = document.getElementById('res');
	div.innerHTML = 'Your fingerprint: ' + gl.canvas.toDataURL().hashCode();
}



</script>
	
</body>
</html>